<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>Dashboard de Monitoreo en Tiempo Real</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
      rel="stylesheet"
    />
    <link href="./web-client-simulator.css" rel="stylesheet" />
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-messaging-compat.js"></script>
  </head>
  <body class="sim-body">
    <div class="container-fluid py-4 px-3 px-xl-5">
      <header class="dashboard-hero text-center mb-5">
        <span class="badge text-bg-primary rounded-pill shadow-sm px-3 py-2">
          Simulador de pruebas
        </span>
        <h1 class="mt-3">Panel de monitoreo en tiempo real</h1>
        <p class="lead text-muted">
          Configura el backend, gestiona plantas y dispara alertas sin depender
          del hardware físico.
        </p>
      </header>

      <div class="row g-4">
        <div class="col-12 col-xxl-7 d-flex flex-column gap-4">
          <section class="panel panel-highlight">
            <div class="panel-header">
              <div>
                <h5>Conexión y autenticación</h5>
                <p class="text-muted mb-0">
                  Define la API, WebSocket y obtén un token válido para probar
                  los servicios protegidos.
                </p>
              </div>
            </div>
            <div class="row g-4">
              <div class="col-lg-6">
                <div class="subpanel">
                  <div class="subpanel-title">
                    <i class="bi bi-diagram-3 text-primary me-2"></i>Backend &
                    WebSocket
                  </div>
                  <form class="row g-3 align-items-end" id="settingsForm">
                    <div class="col-12">
                      <div
                        class="d-flex justify-content-between align-items-center"
                      >
                        <label class="form-label mb-0" for="environmentToggle"
                          >Entorno</label
                        >
                        <div class="form-check form-switch m-0">
                          <input
                            class="form-check-input"
                            id="environmentToggle"
                            role="switch"
                            type="checkbox"
                          />
                          <label
                            class="form-check-label"
                            for="environmentToggle"
                          >
                            <span id="environmentLabel">Desarrollo</span>
                          </label>
                        </div>
                      </div>
                      <small class="text-muted"
                        >Desarrollo usa localhost:3000 y producción el servidor
                        EC2.</small
                      >
                    </div>
                    <div class="col-12">
                      <label class="form-label" for="apiBaseInput"
                        >API Base URL</label
                      >
                      <input
                        class="form-control"
                        id="apiBaseInput"
                        placeholder="http://localhost:3000/api"
                        type="url"
                      />
                    </div>
                    <div class="col-12">
                      <label class="form-label" for="wsUrlInput"
                        >WebSocket URL</label
                      >
                      <input
                        class="form-control"
                        id="wsUrlInput"
                        placeholder="ws://localhost:3000"
                        type="url"
                      />
                    </div>
                    <div class="col-9">
                      <label class="form-label" for="authTokenInput"
                        >Access Token (Bearer)</label
                      >
                      <input
                        autocomplete="off"
                        class="form-control"
                        id="authTokenInput"
                        placeholder="jwt..."
                        type="text"
                      />
                    </div>
                    <div class="col-3 d-grid">
                      <button class="btn btn-primary" type="submit">
                        <i class="bi bi-cloud-check"></i> Guardar
                      </button>
                    </div>
                  </form>
                  <small class="text-muted"
                    >Los cambios se almacenan en tu navegador.</small
                  >
                </div>
              </div>
              <div class="col-lg-6">
                <div class="subpanel h-100">
                  <div class="subpanel-title">
                    <i class="bi bi-shield-lock text-primary me-2"></i>Inicio de
                    sesión rápido
                  </div>
                  <form class="row g-3 align-items-end" id="loginForm">
                    <div class="col-12">
                      <label class="form-label" for="loginUsernameInput"
                        >Usuario</label
                      >
                      <input
                        autocomplete="username"
                        class="form-control"
                        id="loginUsernameInput"
                        placeholder="admin"
                        required
                        type="text"
                      />
                    </div>
                    <div class="col-12">
                      <label class="form-label" for="loginPasswordInput"
                        >Contraseña</label
                      >
                      <input
                        autocomplete="current-password"
                        class="form-control"
                        id="loginPasswordInput"
                        placeholder="••••••••"
                        required
                        type="password"
                      />
                    </div>
                    <div class="col-12 d-grid">
                      <button class="btn btn-dark" type="submit">
                        <i class="bi bi-door-open"></i> Iniciar sesión
                      </button>
                    </div>
                    <div class="col-12">
                      <div class="text-muted small" id="loginStatus"></div>
                    </div>
                  </form>
                </div>
              </div>
            </div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <div>
                <h5>Cliente FCM integrado</h5>
                <p class="text-muted mb-0">
                  Inicializa Firebase, solicita permisos y genera tokens web sin
                  salir del panel.
                </p>
              </div>
            </div>
            <form class="row g-3" id="firebaseConfigForm">
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseApiKeyInput"
                  >API Key</label
                >
                <input
                  class="form-control"
                  id="firebaseApiKeyInput"
                  placeholder="AIza..."
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseAuthDomainInput"
                  >Auth Domain</label
                >
                <input
                  class="form-control"
                  id="firebaseAuthDomainInput"
                  placeholder="mi-app.firebaseapp.com"
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseProjectIdInput"
                  >Project ID</label
                >
                <input
                  class="form-control"
                  id="firebaseProjectIdInput"
                  placeholder="mi-app"
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseStorageBucketInput"
                  >Storage Bucket</label
                >
                <input
                  class="form-control"
                  id="firebaseStorageBucketInput"
                  placeholder="mi-app.appspot.com"
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseSenderIdInput"
                  >Messaging Sender ID</label
                >
                <input
                  class="form-control"
                  id="firebaseSenderIdInput"
                  placeholder="1234567890"
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseAppIdInput"
                  >App ID</label
                >
                <input
                  class="form-control"
                  id="firebaseAppIdInput"
                  placeholder="1:1234567890:web:abc123"
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseMeasurementIdInput"
                  >Measurement ID (opcional)</label
                >
                <input
                  class="form-control"
                  id="firebaseMeasurementIdInput"
                  placeholder="G-XXXXXXX"
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4">
                <label class="form-label" for="firebaseVapidKeyInput"
                  >VAPID key pública</label
                >
                <input
                  class="form-control"
                  id="firebaseVapidKeyInput"
                  placeholder="BNc..."
                  type="text"
                />
              </div>
              <div class="col-md-6 col-xl-4 d-grid">
                <button class="btn btn-outline-primary mt-md-4" type="submit">
                  <i class="bi bi-save2"></i> Guardar configuración
                </button>
              </div>
            </form>
            <div class="row g-3 align-items-end mt-1">
              <div class="col-md-4 d-grid">
                <button class="btn btn-primary" id="firebaseInitBtn">
                  <i class="bi bi-rocket"></i> Inicializar cliente
                </button>
              </div>
              <div class="col-md-4 d-grid">
                <button
                  class="btn btn-outline-secondary"
                  id="firebasePermissionBtn"
                >
                  <i class="bi bi-bell"></i> Solicitar permiso
                </button>
              </div>
              <div class="col-md-4 d-grid">
                <button class="btn btn-success" id="firebaseGetTokenBtn">
                  <i class="bi bi-cloud-arrow-down"></i> Obtener token web
                </button>
              </div>
              <div class="col-12">
                <div class="text-muted small" id="firebaseStatus"></div>
              </div>
            </div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <div>
                <h5>Gestión de plantas y umbrales</h5>
                <p class="text-muted mb-0">
                  Aplica los umbrales a cada sensor y mantenlos sincronizados
                  con el motor de alertas. Solo <strong>ESP32_1</strong> envía notificaciones en tiempo real; <strong>ESP32_2</strong> se reserva para reportes históricos.
                </p>
              </div>
            </div>
            <form class="row g-3" id="plantForm">
              <div class="col-md-4">
                <label class="form-label" for="plantNameInput">Nombre</label>
                <input
                  class="form-control"
                  id="plantNameInput"
                  placeholder="Ej: Lavanda demo"
                  required
                  type="text"
                />
              </div>
              <div class="col-md-4">
                <label class="form-label" for="plantDeviceInput"
                  >Dispositivo asignado</label
                >
                <input
                  class="form-control"
                  id="plantDeviceInput"
                  list="devicesDatalist"
                  placeholder="ESP32_1"
                  type="text"
                />
              </div>
              <div class="col-md-4">
                <label class="form-label">Umbrales iniciales</label>
                <div class="small text-muted">
                  Ajusta los valores por sensor antes de registrar la planta.
                </div>
              </div>
              <div class="col-12">
                <div class="table-responsive panel-table">
                  <table class="table table-sm align-middle mb-0">
                    <thead>
                      <tr>
                        <th>Sensor</th>
                        <th>Umbral mínimo</th>
                        <th>Umbral máximo</th>
                      </tr>
                    </thead>
                    <tbody id="plantThresholdsBody"></tbody>
                  </table>
                </div>
              </div>
              <div class="col-md-3">
                <button class="btn btn-success w-100" id="plantSubmitBtn" type="submit">
                  <i class="bi bi-plant"></i> Crear planta
                </button>
              </div>
              <div class="col-md-3 d-none" id="plantCancelEditCol">
                <button
                  class="btn btn-outline-danger w-100"
                  id="plantCancelEditBtn"
                  type="button"
                >
                  <i class="bi bi-x-circle"></i> Cancelar edición
                </button>
              </div>
              <div class="col-md-3">
                <button
                  class="btn btn-outline-secondary w-100"
                  id="refreshPlantsBtn"
                  type="button"
                >
                  <i class="bi bi-arrow-repeat"></i> Actualizar listado
                </button>
              </div>
              <div class="col-12">
                <div class="text-muted small" id="plantStatus"></div>
              </div>
            </form>
            <div class="table-responsive panel-table mt-3">
              <table class="table table-bordered align-middle mb-0">
                <thead class="table-light">
                  <tr>
                    <th>Nombre</th>
                    <th>Dispositivo</th>
                    <th>Umbrales configurados</th>
                    <th>Actualización</th>
                    <th class="text-center" style="width: 200px;">Acciones</th>
                  </tr>
                </thead>
                <tbody id="plantsTableBody">
                  <tr>
                    <td class="text-center text-muted" colspan="5">
                      Aún no hay plantas cargadas.
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <div>
                <h5>Registro de tokens FCM</h5>
                <p class="text-muted mb-0">
                  Asocia tokens de Android, iOS o web al backend para recibir
                  alertas push.
                </p>
              </div>
            </div>
            <form class="row g-3 align-items-end" id="fcmForm">
              <div class="col-md-4">
                <label class="form-label" for="fcmTokenInput">Token FCM</label>
                <input
                  class="form-control"
                  id="fcmTokenInput"
                  placeholder="token generado por Firebase"
                  required
                  type="text"
                />
              </div>
              <div class="col-md-3">
                <label class="form-label" for="fcmDeviceIdInput"
                  >ID de dispositivo</label
                >
                <input
                  class="form-control"
                  id="fcmDeviceIdInput"
                  list="devicesDatalist"
                  placeholder="ESP32_1"
                  type="text"
                />
              </div>
              <div class="col-md-3">
                <label class="form-label" for="fcmPlatformInput"
                  >Plataforma</label
                >
                <select class="form-select" id="fcmPlatformInput">
                  <option value="">Detectar automáticamente</option>
                  <option value="android">Android</option>
                  <option value="ios">iOS</option>
                  <option value="web">Web</option>
                  <option value="other">Otra</option>
                </select>
              </div>
              <div class="col-md-2">
                <button class="btn btn-primary w-100" type="submit">
                  <i class="bi bi-bell-fill"></i> Registrar
                </button>
              </div>
              <div class="col-12">
                <div class="text-muted small" id="fcmStatus">Solo los dispositivos registrados como ESP32_1 recibirán estas alertas push.</div>
              </div>
            </form>
          </section>
        </div>

        <div class="col-12 col-xxl-5 d-flex flex-column gap-4">
          <section class="panel h-100">
            <div class="panel-header">
              <div>
                <h5>Operaciones en tiempo real</h5>
                <p class="text-muted mb-0">
                  Suscríbete, ajusta umbrales o envía lecturas para disparar
                  alertas.
                </p>
              </div>
            </div>
            <div class="subpanel mb-3">
              <div class="subpanel-title">
                <i class="bi bi-plug text-primary me-2"></i>Suscripción a
                dispositivos
              </div>
              <div class="input-group">
                <input
                  class="form-control"
                  id="deviceIdInput"
                  placeholder="Ej: ESP32_1 o ESP32_2"
                  type="text"
                  value="ESP32_1"
                />
                <button class="btn btn-primary" id="subscribeBtn">
                  <i class="bi bi-plus-circle"></i> Suscribirse
                </button>
              </div>
            </div>
            <div class="subpanel mb-3">
              <div class="subpanel-title">
                <i class="bi bi-sliders text-primary me-2"></i>Configuración
                manual de umbrales
              </div>
              <form class="row g-3 align-items-end" id="thresholdForm">
                <div class="col-lg-4">
                  <label class="form-label" for="thresholdDeviceInput"
                    >Dispositivo</label
                  >
                  <input
                    class="form-control"
                    id="thresholdDeviceInput"
                    list="devicesDatalist"
                    placeholder="ESP32_1"
                    type="text"
                  />
                  <datalist id="devicesDatalist"></datalist>
                </div>
                <div class="col-lg-4">
                  <label class="form-label" for="sensorTypeSelect"
                    >Sensor</label
                  >
                  <select class="form-select" id="sensorTypeSelect">
                    <option value="temperature">Temperatura</option>
                    <option value="humidity">Humedad</option>
                    <option value="soil_humidity">Humedad del Suelo</option>
                    <option value="solar_radiation">Radiación Solar</option>
                  </select>
                </div>
                <div class="col-lg-2">
                  <label class="form-label" for="minThresholdInput"
                    >Mínimo</label
                  >
                  <input
                    class="form-control"
                    id="minThresholdInput"
                    placeholder="Ej: 15"
                    step="any"
                    type="number"
                  />
                </div>
                <div class="col-lg-2">
                  <label class="form-label" for="maxThresholdInput"
                    >Máximo</label
                  >
                  <input
                    class="form-control"
                    id="maxThresholdInput"
                    placeholder="Ej: 35"
                    step="any"
                    type="number"
                  />
                </div>
                <div class="col-12 d-flex flex-column flex-md-row gap-3">
                  <small class="text-muted flex-fill" id="minThresholdHelp">
                    Define el mínimo permitido.
                  </small>
                  <small class="text-muted flex-fill" id="maxThresholdHelp">
                    Define el máximo permitido.
                  </small>
                </div>
                <div class="col-md-3 ms-auto">
                  <button class="btn btn-success w-100" type="submit">
                    <i class="bi bi-save"></i> Guardar
                  </button>
                </div>
              </form>
            </div>
            <div class="subpanel">
              <div class="subpanel-title">
                <i class="bi bi-activity text-primary me-2"></i>Simulador de
                lecturas
              </div>
              <p class="text-muted small mb-3">
                Envía lecturas por WebSocket para disparar los umbrales
                definidos por tus plantas con el fin de probar las
                notificaciones. Recuerda que solo <strong>ESP32_1</strong>
                generará alertas en tiempo real.
              </p>
              <form class="row g-3 align-items-end" id="sensorForm">
                <div class="col-lg-4">
                  <label class="form-label" for="sensorDeviceInput"
                    >Dispositivo</label
                  >
                  <input
                    class="form-control"
                    id="sensorDeviceInput"
                    list="devicesDatalist"
                    placeholder="ESP32_1"
                    required
                    type="text"
                  />
                </div>
                <div class="col-lg-4">
                  <label class="form-label" for="sensorTypeSimulation"
                    >Sensor</label
                  >
                  <select class="form-select" id="sensorTypeSimulation">
                    <option value="temperature">Temperatura</option>
                    <option value="humidity">Humedad</option>
                    <option value="soil_humidity">Humedad del Suelo</option>
                    <option value="solar_radiation">Radiación Solar</option>
                  </select>
                </div>
                <div class="col-lg-2">
                  <label class="form-label" for="sensorValueInput">Valor</label>
                  <input
                    class="form-control"
                    id="sensorValueInput"
                    placeholder="Ej: 32"
                    required
                    step="any"
                    type="number"
                  />
                </div>
                <div class="col-lg-2">
                  <label class="form-label" for="sensorUnitInput">Unidad</label>
                  <input
                    class="form-control"
                    id="sensorUnitInput"
                    placeholder="°C"
                    type="text"
                  />
                </div>
                <div class="col-md-3 ms-auto">
                  <button class="btn btn-warning w-100" type="submit">
                    <i class="bi bi-send"></i> Enviar
                  </button>
                </div>
                <div class="col-12">
                  <div class="text-muted small" id="sensorStatus"></div>
                </div>
              </form>
            </div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <div>
                <h5>Dispositivos suscritos</h5>
                <p class="text-muted mb-0">
                  Visualiza las últimas lecturas recibidas.
                </p>
              </div>
            </div>
            <div class="device-grid" id="devices-container"></div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <div>
                <h5>Alertas recientes</h5>
                <p class="text-muted mb-0">
                  Incluye el contexto de la planta y el umbral disparado.
                </p>
              </div>
            </div>
            <div class="list-group small alert-list" id="alertsList">
              <div class="list-group-item text-muted text-center">
                Aún no se han recibido alertas.
              </div>
            </div>
          </section>

          <section class="panel">
            <div class="panel-header">
              <div>
                <h5>Bitácora en vivo</h5>
                <p class="text-muted mb-0">
                  Revisa las acciones y eventos recibidos del servidor.
                </p>
              </div>
            </div>
            <div class="log-console" id="logs"></div>
          </section>
        </div>
      </div>
    </div>
    <script>
      const logs = document.getElementById("logs");
      const deviceIdInput = document.getElementById("deviceIdInput");
      const subscribeBtn = document.getElementById("subscribeBtn");
      const devicesContainer = document.getElementById("devices-container");
      const thresholdForm = document.getElementById("thresholdForm");
      const sensorTypeSelect = document.getElementById("sensorTypeSelect");
      const minThresholdInput = document.getElementById("minThresholdInput");
      const maxThresholdInput = document.getElementById("maxThresholdInput");
      const thresholdDeviceInput = document.getElementById(
        "thresholdDeviceInput",
      );
      const devicesDatalist = document.getElementById("devicesDatalist");
      const minThresholdHelp = document.getElementById("minThresholdHelp");
      const maxThresholdHelp = document.getElementById("maxThresholdHelp");
      const settingsForm = document.getElementById("settingsForm");
      const environmentToggle = document.getElementById("environmentToggle");
      const environmentLabel = document.getElementById("environmentLabel");
      const apiBaseInput = document.getElementById("apiBaseInput");
      const wsUrlInput = document.getElementById("wsUrlInput");
      const authTokenInput = document.getElementById("authTokenInput");
      const loginForm = document.getElementById("loginForm");
      const loginUsernameInput = document.getElementById("loginUsernameInput");
      const loginPasswordInput = document.getElementById("loginPasswordInput");
      const loginStatus = document.getElementById("loginStatus");
      const firebaseConfigForm = document.getElementById("firebaseConfigForm");
      const firebaseStatus = document.getElementById("firebaseStatus");
      const firebaseInitBtn = document.getElementById("firebaseInitBtn");
      const firebasePermissionBtn = document.getElementById(
        "firebasePermissionBtn",
      );
      const firebaseGetTokenBtn = document.getElementById(
        "firebaseGetTokenBtn",
      );
      const firebaseApiKeyInput = document.getElementById(
        "firebaseApiKeyInput",
      );
      const firebaseAuthDomainInput = document.getElementById(
        "firebaseAuthDomainInput",
      );
      const firebaseProjectIdInput = document.getElementById(
        "firebaseProjectIdInput",
      );
      const firebaseStorageBucketInput = document.getElementById(
        "firebaseStorageBucketInput",
      );
      const firebaseSenderIdInput = document.getElementById(
        "firebaseSenderIdInput",
      );
      const firebaseAppIdInput = document.getElementById("firebaseAppIdInput");
      const firebaseMeasurementIdInput = document.getElementById(
        "firebaseMeasurementIdInput",
      );
      const firebaseVapidKeyInput = document.getElementById(
        "firebaseVapidKeyInput",
      );
      const plantForm = document.getElementById("plantForm");
      const plantNameInput = document.getElementById("plantNameInput");
      const plantDeviceInput = document.getElementById("plantDeviceInput");
      const plantThresholdsBody = document.getElementById(
        "plantThresholdsBody",
      );
      const plantsTableBody = document.getElementById("plantsTableBody");
      const plantStatus = document.getElementById("plantStatus");
      const plantSubmitBtn = document.getElementById("plantSubmitBtn");
      const plantCancelEditBtn = document.getElementById("plantCancelEditBtn");
      const plantCancelEditCol = document.getElementById("plantCancelEditCol");
      const refreshPlantsBtn = document.getElementById("refreshPlantsBtn");
      const fcmForm = document.getElementById("fcmForm");
      const fcmTokenInput = document.getElementById("fcmTokenInput");
      const fcmDeviceIdInput = document.getElementById("fcmDeviceIdInput");
      const fcmPlatformInput = document.getElementById("fcmPlatformInput");
      const fcmStatus = document.getElementById("fcmStatus");
      const sensorForm = document.getElementById("sensorForm");
      const sensorDeviceInput = document.getElementById("sensorDeviceInput");
      const sensorTypeSimulation = document.getElementById(
        "sensorTypeSimulation",
      );
      const sensorValueInput = document.getElementById("sensorValueInput");
      const sensorUnitInput = document.getElementById("sensorUnitInput");
      const sensorStatus = document.getElementById("sensorStatus");
      const alertsList = document.getElementById("alertsList");

      const SENSOR_METADATA = {
        temperature: {
          name: "Temperatura",
          icon: '<i class="bi bi-thermometer-half text-danger"></i>',
          unit: "°C",
          decimals: 2,
          examples: { min: 15, max: 35 },
        },
        humidity: {
          name: "Humedad",
          icon: '<i class="bi bi-droplet-half text-info"></i>',
          unit: "%",
          decimals: 2,
          examples: { min: 40, max: 90 },
        },
        soil_humidity: {
          name: "Humedad del Suelo",
          icon: '<i class="bi bi-flower3 text-success"></i>',
          unit: "%",
          decimals: 2,
          examples: { min: 20 },
          readOnly: true,
          fixedMin: 20,
        },
        solar_radiation: {
          name: "Radiación Solar",
          icon: '<i class="bi bi-brightness-high text-warning"></i>',
          unit: "W/m²",
          decimals: 0,
          examples: { max: 1000 },
        },
      };

      const ENVIRONMENTS = {
        development: {
          label: "Desarrollo",
          apiBase: "http://localhost:3000/api",
          wsUrl: "ws://localhost:3000",
        },
        production: {
          label: "Producción",
          apiBase: "http://ec2-98-86-100-220.compute-1.amazonaws.com:3000/api",
          wsUrl: "ws://ec2-98-86-100-220.compute-1.amazonaws.com:3000",
        },
      };

      const DEFAULT_FIREBASE_CONFIG = {
        apiKey: "AIzaSyBRftDkf-IAl4RB_8xhFKUJsLxuO9ysiyc",
        authDomain: "monitoring-system-f50e6.firebaseapp.com",
        projectId: "monitoring-system-f50e6",
        storageBucket: "monitoring-system-f50e6.firebasestorage.app",
        messagingSenderId: "350176906989",
        appId: "1:350176906989:web:c0b4b7e723f1003fa406e4",
        measurementId: "G-GB0XYE79W2",
      };
      const DEFAULT_FIREBASE_VAPID_KEY = "";

      const STORAGE_KEYS = {
        apiBase: "simulator.apiBaseUrl",
        wsUrl: "simulator.wsUrl",
        token: "simulator.authToken",
        firebaseConfig: "simulator.firebaseConfig",
        firebaseVapid: "simulator.firebaseVapidKey",
        environment: "simulator.environment",
      };
      const SESSION_KEYS = {
        plantDraft: "simulator.session.plantDraft",
        thresholdDraft: "simulator.session.thresholdDraft",
        sensorDraft: "simulator.session.sensorDraft",
        fcmDraft: "simulator.session.fcmDraft",
        knownDevices: "simulator.session.knownDevices",
        subscriptions: "simulator.session.subscriptions",
      };

      function saveSessionState(key, value) {
        try {
          window.sessionStorage.setItem(key, JSON.stringify(value));
        } catch (error) {
          console.warn("No se pudo guardar el estado de sesión:", error);
        }
      }

      function loadSessionState(key, fallback = null) {
        try {
          const raw = window.sessionStorage.getItem(key);
          if (!raw) return fallback;
          const parsed = JSON.parse(raw);
          return parsed ?? fallback;
        } catch (error) {
          console.warn("No se pudo restaurar el estado de sesión:", error);
          return fallback;
        }
      }

      function clearSessionState(key) {
        try {
          window.sessionStorage.removeItem(key);
        } catch (error) {
          console.warn("No se pudo limpiar el estado de sesión:", error);
        }
      }

      let currentEnvironment =
        window.localStorage.getItem(STORAGE_KEYS.environment) || "development";
      if (!ENVIRONMENTS[currentEnvironment]) {
        currentEnvironment = "development";
      }

      let apiBaseUrl =
        window.localStorage.getItem(STORAGE_KEYS.apiBase) ||
        ENVIRONMENTS[currentEnvironment].apiBase;
      let wsUrl =
        window.localStorage.getItem(STORAGE_KEYS.wsUrl) ||
        ENVIRONMENTS[currentEnvironment].wsUrl;
      let authToken = window.localStorage.getItem(STORAGE_KEYS.token) || "";
      let firebaseClientConfig = loadStoredFirebaseConfig();
      let firebaseVapidKey =
        window.localStorage.getItem(STORAGE_KEYS.firebaseVapid) ||
        DEFAULT_FIREBASE_VAPID_KEY;

      if (!firebaseClientConfig) {
        firebaseClientConfig = { ...DEFAULT_FIREBASE_CONFIG };
      }

      updateEnvironmentDisplay();

      if (apiBaseInput) {
        apiBaseInput.value = apiBaseUrl;
      }
      if (wsUrlInput) {
        wsUrlInput.value = wsUrl;
      }
      if (authTokenInput) authTokenInput.value = authToken;

      const storedKnownDevices = loadSessionState(SESSION_KEYS.knownDevices, []);
      const knownDevices = new Set(["ESP32_1", "ESP32_2"]);
      if (Array.isArray(storedKnownDevices)) {
        for (const deviceId of storedKnownDevices) {
          if (typeof deviceId === "string" && deviceId.trim()) {
            knownDevices.add(deviceId.trim());
          }
        }
      }

      const storedSubscriptions = loadSessionState(
        SESSION_KEYS.subscriptions,
        [],
      );
      const subscribedDevices = new Set(
        Array.isArray(storedSubscriptions)
          ? storedSubscriptions.filter(
              (deviceId) => typeof deviceId === "string" && deviceId.trim(),
            )
          : [],
      );

      let cachedPlants = [];
      let editingPlantId = null;
      const pendingWsMessages = [];
      let firebaseMessagingInstance = null;
      let firebaseServiceWorkerRegistration = null;
      let firebaseInitializationInProgress = false;

      populateFirebaseInputs(firebaseClientConfig);
      if (firebaseVapidKeyInput && firebaseVapidKey) {
        firebaseVapidKeyInput.value = firebaseVapidKey;
      }

      let socket = null;

      refreshDeviceSuggestions();
      if (thresholdDeviceInput && !thresholdDeviceInput.value) {
        thresholdDeviceInput.value = "ESP32_1";
      }
      if (plantDeviceInput && !plantDeviceInput.value) {
        plantDeviceInput.value = "ESP32_1";
      }
      if (sensorDeviceInput && !sensorDeviceInput.value) {
        sensorDeviceInput.value = "ESP32_1";
      }

      if (sensorTypeSelect) {
        const currentValue = sensorTypeSelect.value;
        sensorTypeSelect.innerHTML = Object.entries(SENSOR_METADATA)
          .map(
            ([value, meta]) => `<option value="${value}">${meta.name}</option>`,
          )
          .join("");
        if (SENSOR_METADATA[currentValue]) {
          sensorTypeSelect.value = currentValue;
        }
        sensorTypeSelect.addEventListener("change", updateThresholdHints);
      }

      resetPlantForm({ keepDraft: true });
      updateThresholdHints();
      restoreThresholdFormState();
      restorePlantFormDraft();
      updateSensorSimulationHints();
      restoreSensorFormState();
      restoreFcmFormState();
      restoreSubscribedDeviceCards();
      connectWebSocket();

      if (environmentToggle) {
        environmentToggle.addEventListener("change", () => {
          const nextEnvironment = environmentToggle.checked
            ? "production"
            : "development";
          if (nextEnvironment === currentEnvironment) {
            return;
          }
          currentEnvironment = nextEnvironment;
          window.localStorage.setItem(
            STORAGE_KEYS.environment,
            currentEnvironment,
          );
          updateEnvironmentDisplay();
          applyEnvironmentSelection();
        });
      }

      if (settingsForm) {
        settingsForm.addEventListener("submit", (event) => {
          event.preventDefault();
          apiBaseUrl = apiBaseInput.value.trim() || apiBaseUrl;
          wsUrl = wsUrlInput.value.trim() || wsUrl;
          authToken = authTokenInput.value.trim();

          window.localStorage.setItem(STORAGE_KEYS.apiBase, apiBaseUrl);
          window.localStorage.setItem(STORAGE_KEYS.wsUrl, wsUrl);
          window.localStorage.setItem(STORAGE_KEYS.token, authToken);

          logMessage("Configuración guardada. Reconectando WebSocket...");
          connectWebSocket();
        });
      }

      if (loginForm) {
        loginForm.addEventListener("submit", handleLoginSubmit);
      }

      if (firebaseConfigForm) {
        firebaseConfigForm.addEventListener(
          "submit",
          handleFirebaseConfigSubmit,
        );
      }

      if (firebaseInitBtn) {
        firebaseInitBtn.addEventListener("click", async () => {
          if (firebaseStatus) {
            firebaseStatus.textContent = "Inicializando cliente Firebase...";
            firebaseStatus.className = "text-muted small";
          }
          try {
            await initializeFirebaseClient();
            if (firebaseStatus) {
              firebaseStatus.textContent =
                "Firebase Messaging inicializado correctamente.";
              firebaseStatus.className = "text-success small";
            }
          } catch (error) {
            console.error(error);
            if (firebaseStatus) {
              firebaseStatus.textContent =
                error instanceof Error
                  ? error.message
                  : "No se pudo inicializar Firebase.";
              firebaseStatus.className = "text-danger small";
            }
          }
        });
      }

      if (firebasePermissionBtn) {
        firebasePermissionBtn.addEventListener("click", async () => {
          try {
            await handleRequestNotificationPermission();
            if (firebaseStatus) {
              firebaseStatus.textContent =
                "Permiso de notificaciones otorgado.";
              firebaseStatus.className = "text-success small";
            }
          } catch (error) {
            if (firebaseStatus) {
              firebaseStatus.textContent =
                error instanceof Error ? error.message : "Permiso rechazado.";
              firebaseStatus.className = "text-danger small";
            }
          }
        });
      }

      if (firebaseGetTokenBtn) {
        firebaseGetTokenBtn.addEventListener("click", async () => {
          if (firebaseStatus) {
            firebaseStatus.textContent =
              "Obteniendo token web (esto puede demorar unos segundos)...";
            firebaseStatus.className = "text-muted small";
          }
          try {
            const token = await handleGetBrowserFcmToken();
            if (fcmTokenInput && token) {
              fcmTokenInput.value = token;
              persistFcmFormState();
            }
            if (firebaseStatus) {
              firebaseStatus.textContent = "Token web generado correctamente.";
              firebaseStatus.className = "text-success small";
            }
            if (fcmStatus) {
              fcmStatus.textContent =
                "Token rellenado automáticamente. Puedes registrarlo en la tarjeta inferior.";
              fcmStatus.className = "text-success small";
            }
          } catch (error) {
            console.error(error);
            if (firebaseStatus) {
              firebaseStatus.textContent =
                error instanceof Error
                  ? error.message
                  : "No se pudo obtener el token.";
              firebaseStatus.className = "text-danger small";
            }
          }
        });
      }

      if (subscribeBtn) {
        subscribeBtn.addEventListener("click", () => {
          const deviceId = deviceIdInput.value.trim();
          if (!deviceId) {
            alert("Introduce un ID de dispositivo.");
            return;
          }
          if (subscribedDevices.has(deviceId)) {
            logMessage(`Ya estás suscrito a ${deviceId}`);
            return;
          }

          sendWsMessage(
            JSON.stringify({
              event: "subscribeToDevice",
              deviceId,
            }),
          );
          logMessage(`Suscrito a: ${deviceId}`);
          registerKnownDevice(deviceId);
          createDeviceCard(deviceId);
          subscribedDevices.add(deviceId);
          persistSubscribedDevices();
          deviceIdInput.value = "";
        });

        deviceIdInput.addEventListener("keyup", (event) => {
          if (event.key === "Enter") subscribeBtn.click();
        });
      }

      if (thresholdForm) {
        thresholdForm.addEventListener("submit", (event) => {
          event.preventDefault();
          const meta = SENSOR_METADATA[sensorTypeSelect.value] || {};
          const deviceIdRaw = thresholdDeviceInput
            ? thresholdDeviceInput.value.trim()
            : "";
          const deviceId = deviceIdRaw || "ESP32_1";
          const sensorType = sensorTypeSelect.value;
          const isMinDisabled = !!minThresholdInput?.disabled;
          const isMaxDisabled = !!maxThresholdInput?.disabled;
          const minValue = minThresholdInput.value.trim();
          const maxValue = maxThresholdInput.value.trim();

          const payload = {
            event: "updateThresholds",
            sensorType,
            deviceId,
          };

          if (!meta.readOnly && !isMinDisabled && minValue !== "") {
            const parsedMin = Number(minValue);
            if (Number.isNaN(parsedMin)) {
              alert("El umbral mínimo debe ser un número válido.");
              return;
            }
            payload.min = parsedMin;
          }

          if (!meta.readOnly && !isMaxDisabled && maxValue !== "") {
            const parsedMax = Number(maxValue);
            if (Number.isNaN(parsedMax)) {
              alert("El umbral máximo debe ser un número válido.");
              return;
            }
            payload.max = parsedMax;
          }

          if (
            payload.min !== undefined &&
            payload.max !== undefined &&
            payload.min > payload.max
          ) {
            alert("El umbral mínimo no puede ser mayor al máximo.");
            return;
          }

          if (meta.readOnly) {
            logMessage(
              `El umbral de ${getSensorName(
                sensorType,
              )} es fijo y no requiere configuración.`,
            );
            return;
          }

          registerKnownDevice(deviceId);
          sendWsMessage(JSON.stringify(payload));
          logMessage(
            `Configurando umbrales para ${deviceId} / ${getSensorName(
              sensorType,
            )}...`,
          );
        });
        thresholdForm.addEventListener("input", persistThresholdFormState);
        thresholdForm.addEventListener("change", persistThresholdFormState);
      }

      if (plantForm) {
        plantForm.addEventListener("submit", handlePlantFormSubmit);
        plantForm.addEventListener("input", persistPlantFormDraft);
        plantForm.addEventListener("change", persistPlantFormDraft);
      }

      if (plantCancelEditBtn) {
        plantCancelEditBtn.addEventListener("click", () => {
          resetPlantForm();
          if (plantStatus) {
            plantStatus.textContent = "Edición cancelada.";
            plantStatus.className = "text-muted small";
          }
        });
      }

      if (refreshPlantsBtn) {
        refreshPlantsBtn.addEventListener("click", loadPlants);
      }

      if (plantsTableBody) {
        plantsTableBody.addEventListener("click", (event) => {
          if (!(event.target instanceof Element)) return;
          const actionBtn = event.target.closest("[data-plant-action]");
          if (!actionBtn) return;
          const action = actionBtn.getAttribute("data-plant-action");
          const plantId = actionBtn.getAttribute("data-plant-id");
          if (!plantId) return;

          if (action === "edit") {
            const plant = findPlantById(plantId);
            if (!plant) {
              alert("No se pudo cargar la planta seleccionada.");
              return;
            }
            startPlantEdit(plant);
          } else if (action === "delete") {
            const plant = findPlantById(plantId);
            const plantName = plant?.name || "la planta";
            if (
              confirm(
                `¿Eliminar "${plantName}"? Esto actualizará los umbrales del dispositivo asociado.`,
              )
            ) {
              deletePlantById(plantId);
            }
          }
        });
      }

      if (fcmForm) {
        fcmForm.addEventListener("submit", handleFcmSubmit);
        fcmForm.addEventListener("input", persistFcmFormState);
        fcmForm.addEventListener("change", persistFcmFormState);
      }

      if (sensorForm) {
        sensorForm.addEventListener("submit", handleSensorFormSubmit);
        sensorForm.addEventListener("input", persistSensorFormState);
        sensorForm.addEventListener("change", persistSensorFormState);
      }

      if (sensorTypeSimulation) {
        sensorTypeSimulation.addEventListener(
          "change",
          updateSensorSimulationHints,
        );
        sensorTypeSimulation.addEventListener("change", persistSensorFormState);
      }

      function getEnvironmentConfig() {
        return ENVIRONMENTS[currentEnvironment] || ENVIRONMENTS.development;
      }

      function updateEnvironmentDisplay() {
        const config = getEnvironmentConfig();
        if (environmentLabel) {
          environmentLabel.textContent = config.label;
        }
        if (environmentToggle) {
          environmentToggle.checked = currentEnvironment === "production";
        }
        if (apiBaseInput) {
          apiBaseInput.placeholder = config.apiBase;
        }
        if (wsUrlInput) {
          wsUrlInput.placeholder = config.wsUrl;
        }
      }

      function applyEnvironmentSelection() {
        const config = getEnvironmentConfig();
        apiBaseUrl = config.apiBase;
        wsUrl = config.wsUrl;
        if (apiBaseInput) {
          apiBaseInput.value = apiBaseUrl;
        }
        if (wsUrlInput) {
          wsUrlInput.value = wsUrl;
        }
        window.localStorage.setItem(STORAGE_KEYS.apiBase, apiBaseUrl);
        window.localStorage.setItem(STORAGE_KEYS.wsUrl, wsUrl);
        logMessage(
          `Entorno cambiado a ${config.label}. Configuración actualizada.`,
        );
        connectWebSocket();
      }

      function refreshDeviceSuggestions() {
        if (!devicesDatalist) return;
        devicesDatalist.innerHTML = Array.from(knownDevices)
          .sort()
          .map((device) => `<option value="${device}"></option>`)
          .join("");
      }

      function registerKnownDevice(deviceId) {
        const sanitized = deviceId?.trim();
        if (!sanitized) return;
        if (!knownDevices.has(sanitized)) {
          knownDevices.add(sanitized);
          persistKnownDevices();
          refreshDeviceSuggestions();
        }
        if (thresholdDeviceInput && !thresholdDeviceInput.value) {
          thresholdDeviceInput.value = sanitized;
        }
        if (plantDeviceInput && !plantDeviceInput.value) {
          plantDeviceInput.value = sanitized;
        }
        if (sensorDeviceInput && !sensorDeviceInput.value) {
          sensorDeviceInput.value = sanitized;
        }
        persistPlantFormDraft();
        persistThresholdFormState();
        persistSensorFormState();
      }

      function persistKnownDevices() {
        saveSessionState(SESSION_KEYS.knownDevices, Array.from(knownDevices));
      }

      function persistSubscribedDevices() {
        saveSessionState(SESSION_KEYS.subscriptions, Array.from(subscribedDevices));
      }

      function restoreSubscribedDeviceCards() {
        if (!subscribedDevices.size) return;
        for (const deviceId of subscribedDevices) {
          registerKnownDevice(deviceId);
          createDeviceCard(deviceId);
        }
      }

      function connectWebSocket() {
        if (socket) {
          try {
            socket.close();
          } catch (error) {
            console.warn("No se pudo cerrar el socket previo:", error);
          }
        }

        socket = new WebSocket(wsUrl);

        socket.onopen = () => {
          logMessage(`Conectado al servidor WebSocket (${wsUrl}).`);
          if (pendingWsMessages.length) {
            pendingWsMessages.splice(0).forEach((msg) => socket.send(msg));
          }
          for (const deviceId of subscribedDevices) {
            try {
              socket.send(
                JSON.stringify({ event: "subscribeToDevice", deviceId }),
              );
              logMessage(`Suscripción restaurada a ${deviceId}.`);
            } catch (error) {
              console.warn("No se pudo restaurar la suscripción:", error);
            }
          }
        };

        socket.onclose = (event) => {
          logMessage(`Desconectado del servidor (${event.code}).`);
        };

        socket.onerror = (err) => {
          logMessage(`Error en WebSocket: ${err.message || err}`);
        };

        socket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            if (data.event === "newSensorData") {
              const sensorData = data.data;
              const { deviceId, sensorType, value, unit } = sensorData;
              registerKnownDevice(deviceId);
              updateSensorCard(deviceId, sensorType, value, unit);
            } else if (data.event === "sensorAlert") {
              const { deviceId, message } = data;
              showNotification(`Alerta en ${deviceId}`, message);
              logMessage(`${message}`);
              renderAlertDetails(data);
            } else if (data.event === "ack") {
              logMessage(data.message);
            } else if (data.event === "thresholdsUpdated") {
              const { deviceId, sensorType, thresholds } = data;
              registerKnownDevice(deviceId);
              const sensorLabel = getSensorName(sensorType);
              const minLabel =
                thresholds && thresholds.min !== undefined
                  ? formatSensorValue(sensorType, thresholds.min)
                  : "sin mínimo";
              const maxLabel =
                thresholds && thresholds.max !== undefined
                  ? formatSensorValue(sensorType, thresholds.max)
                  : "sin máximo";
              logMessage(
                `Umbrales para ${deviceId} / ${sensorLabel} actualizados: ${minLabel} / ${maxLabel}`,
              );
            } else if (data.event === "thresholdUpdateError") {
              logMessage(`Error al actualizar umbrales: ${data.message}`);
              alert(data.message);
            } else if (data.event === "dataError") {
              logMessage("Error del servidor: " + data.message);
            }
          } catch (err) {
            console.error("Error procesando mensaje:", err, event.data);
          }
        };
      }

      function sendWsMessage(payload) {
        const serialized =
          typeof payload === "string" ? payload : JSON.stringify(payload);
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(serialized);
        } else {
          pendingWsMessages.push(serialized);
          logMessage(
            "Socket no disponible, la acción se enviará al reconectar.",
          );
        }
      }

      function requireAuthToken() {
        if (!authToken) {
          alert(
            "Configura el token de autenticación (Bearer) en la sección de configuración.",
          );
          return false;
        }
        return true;
      }

      function renderAlertDetails(data) {
        if (!alertsList) return;
        if (alertsList.firstElementChild?.classList.contains("text-muted")) {
          alertsList.innerHTML = "";
        }

        const item = document.createElement("div");
        item.className =
          "list-group-item list-group-item-action flex-column align-items-start";

        const sensorName = getSensorName(data.sensorType);
        const firedLabel = data.thresholdType === "max" ? "Máximo" : "Mínimo";
        const thresholdLabel =
          data.thresholdValue !== undefined
            ? formatSensorValue(data.sensorType, data.thresholdValue, data.unit)
            : "sin dato";
        const readingLabel = formatSensorValue(
          data.sensorType,
          data.value,
          data.unit,
        );
        const thresholds =
          data.thresholds && typeof data.thresholds === "object"
            ? data.thresholds
            : {};
        const minThreshold =
          thresholds.min !== undefined
            ? formatSensorValue(data.sensorType, thresholds.min, data.unit)
            : "N/D";
        const maxThreshold =
          thresholds.max !== undefined
            ? formatSensorValue(data.sensorType, thresholds.max, data.unit)
            : "N/D";

        item.innerHTML = `
          <div class="d-flex w-100 justify-content-between">
            <h6 class="mb-1">${sensorName} · Umbral ${firedLabel}</h6>
            <small>${new Date(data.timestamp).toLocaleTimeString()}</small>
          </div>
          <p class="mb-1">${data.message}</p>
          <small>
            Dispositivo: <strong>${data.deviceId}</strong> · Planta asociada:
            <strong>${data.plantName || data.plantId || "sin asociación"}</strong><br/>
            Lectura: <strong>${readingLabel}</strong> · Disparo: <strong>${thresholdLabel}</strong><br/>
            Últimos umbrales — Mínimo: ${minThreshold} · Máximo: ${maxThreshold}
          </small>
        `;

        alertsList.prepend(item);
        while (alertsList.childElementCount > 5) {
          alertsList.removeChild(alertsList.lastElementChild);
        }
      }

      async function handleLoginSubmit(event) {
        event.preventDefault();
        const username = loginUsernameInput.value.trim();
        const password = loginPasswordInput.value;

        if (!username || !password) {
          alert("Debes completar usuario y contraseña.");
          return;
        }

        if (!apiBaseUrl) {
          alert("Configura la URL base del backend antes de iniciar sesión.");
          return;
        }

        if (loginStatus) {
          loginStatus.textContent = "Solicitando token...";
          loginStatus.className = "text-muted small";
        }

        try {
          const response = await fetch(`${apiBaseUrl}/auth/login`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password }),
          });

          const data = await response.json();
          if (!response.ok || !data?.accessToken) {
            throw new Error(
              data?.error || "No se pudo iniciar sesión con esas credenciales.",
            );
          }

          authToken = data.accessToken;
          if (authTokenInput) authTokenInput.value = authToken;
          window.localStorage.setItem(STORAGE_KEYS.token, authToken);

          if (loginStatus) {
            loginStatus.textContent = "Token obtenido correctamente.";
            loginStatus.className = "text-success small";
          }

          await loadPlants();
        } catch (error) {
          console.error(error);
          if (loginStatus) {
            loginStatus.textContent =
              error instanceof Error ? error.message : "Error desconocido.";
            loginStatus.className = "text-danger small";
          }
        }
      }

      function handleFirebaseConfigSubmit(event) {
        event.preventDefault();
        try {
          const config = getFirebaseConfigFromInputs();
          firebaseClientConfig = config;
          saveFirebaseConfig(config);
          firebaseStatus.textContent = "Configuración guardada.";
          firebaseStatus.className = "text-success small";
        } catch (error) {
          console.error(error);
          if (firebaseStatus) {
            firebaseStatus.textContent =
              error instanceof Error
                ? error.message
                : "No se pudo guardar la configuración.";
            firebaseStatus.className = "text-danger small";
          }
        }
      }

      function saveFirebaseConfig(config) {
        if (!config) return;
        window.localStorage.setItem(
          STORAGE_KEYS.firebaseConfig,
          JSON.stringify(config),
        );
      }

      function loadStoredFirebaseConfig() {
        const raw = window.localStorage.getItem(STORAGE_KEYS.firebaseConfig);
        if (!raw) return null;
        try {
          const parsed = JSON.parse(raw);
          return typeof parsed === "object" && parsed ? parsed : null;
        } catch (error) {
          console.warn(
            "No se pudo parsear la configuración Firebase guardada.",
          );
          return null;
        }
      }

      function populateFirebaseInputs(config) {
        if (!config) return;
        if (firebaseApiKeyInput)
          firebaseApiKeyInput.value = config.apiKey ?? "";
        if (firebaseAuthDomainInput)
          firebaseAuthDomainInput.value = config.authDomain ?? "";
        if (firebaseProjectIdInput)
          firebaseProjectIdInput.value = config.projectId ?? "";
        if (firebaseStorageBucketInput)
          firebaseStorageBucketInput.value = config.storageBucket ?? "";
        if (firebaseSenderIdInput)
          firebaseSenderIdInput.value = config.messagingSenderId ?? "";
        if (firebaseAppIdInput) firebaseAppIdInput.value = config.appId ?? "";
        if (firebaseMeasurementIdInput)
          firebaseMeasurementIdInput.value = config.measurementId ?? "";
      }

      function getFirebaseConfigFromInputs() {
        const config = {
          apiKey: firebaseApiKeyInput?.value.trim(),
          authDomain: firebaseAuthDomainInput?.value.trim(),
          projectId: firebaseProjectIdInput?.value.trim(),
          storageBucket: firebaseStorageBucketInput?.value.trim(),
          messagingSenderId: firebaseSenderIdInput?.value.trim(),
          appId: firebaseAppIdInput?.value.trim(),
          measurementId: firebaseMeasurementIdInput?.value.trim(),
        };

        const missing = Object.entries(config)
          .filter(([key, value]) => {
            if (key === "measurementId") return false;
            return !value;
          })
          .map(([key]) => key);

        if (missing.length) {
          throw new Error(
            `Faltan campos obligatorios de Firebase: ${missing.join(", ")}`,
          );
        }

        if (!config.measurementId) {
          delete config.measurementId;
        }

        return config;
      }

      async function initializeFirebaseClient() {
        if (!window.firebase) {
          throw new Error("El SDK de Firebase no se ha cargado correctamente.");
        }

        if (firebaseInitializationInProgress) {
          return firebaseMessagingInstance;
        }

        firebaseInitializationInProgress = true;
        try {
          const config = firebaseClientConfig || getFirebaseConfigFromInputs();

          firebaseClientConfig = config;
          saveFirebaseConfig(config);

          if (!firebase.apps.length) {
            firebase.initializeApp(config);
          }

          firebaseMessagingInstance = firebase.messaging();
          firebaseServiceWorkerRegistration =
            await registerMessagingServiceWorker(config);

          return firebaseMessagingInstance;
        } finally {
          firebaseInitializationInProgress = false;
        }
      }

      async function ensureFirebaseInitialized() {
        if (firebaseMessagingInstance) {
          return firebaseMessagingInstance;
        }
        return initializeFirebaseClient();
      }

      async function registerMessagingServiceWorker(config) {
        if (!("serviceWorker" in navigator)) {
          throw new Error(
            "El navegador no soporta Service Workers, no se puede usar FCM web.",
          );
        }

        const registration = await navigator.serviceWorker.register(
          "./firebase-messaging-sw.js",
          {
            scope: "./",
          },
        );

        navigator.serviceWorker.addEventListener("controllerchange", () => {
          void sendConfigToServiceWorker(config).catch((error) =>
            console.error("No se pudo reenviar la configuración a SW:", error),
          );
        });

        await navigator.serviceWorker.ready;
        await sendConfigToServiceWorker(config);
        return registration;
      }

      async function sendConfigToServiceWorker(config) {
        const message = { type: "INIT_FIREBASE", config };
        if (navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage(message);
        }
        try {
          const readyRegistration = await navigator.serviceWorker.ready;
          readyRegistration.active?.postMessage(message);
        } catch (error) {
          console.warn(
            "No se pudo notificar al Service Worker sobre Firebase:",
            error,
          );
        }
      }

      async function handleRequestNotificationPermission() {
        if (!("Notification" in window)) {
          throw new Error("El navegador no soporta notificaciones.");
        }
        if (Notification.permission === "granted") {
          return;
        }
        const permission = await Notification.requestPermission();
        if (permission !== "granted") {
          throw new Error("Debes otorgar permiso para recibir notificaciones.");
        }
      }

      async function handleGetBrowserFcmToken() {
        const messaging = await ensureFirebaseInitialized();
        await handleRequestNotificationPermission();

        let vapidKeyValue = firebaseVapidKeyInput?.value.trim();
        if (vapidKeyValue) {
          window.localStorage.setItem(
            STORAGE_KEYS.firebaseVapid,
            vapidKeyValue,
          );
          firebaseVapidKey = vapidKeyValue;
        } else if (firebaseVapidKey) {
          vapidKeyValue = firebaseVapidKey;
        }

        const registration =
          firebaseServiceWorkerRegistration ||
          (await navigator.serviceWorker.ready);

        const token = await messaging.getToken({
          vapidKey: vapidKeyValue || undefined,
          serviceWorkerRegistration: registration,
        });

        if (!token) {
          throw new Error(
            "Firebase Messaging no devolvió un token. Verifica la configuración y el dominio.",
          );
        }

        return token;
      }

      async function handlePlantFormSubmit(event) {
        event.preventDefault();
        if (!requireAuthToken()) return;

        const name = plantNameInput.value.trim();
        if (!name) {
          alert("El nombre de la planta es obligatorio.");
          return;
        }

        const deviceId =
          (plantDeviceInput.value && plantDeviceInput.value.trim()) ||
          "ESP32_1";

        const isEditing = Boolean(editingPlantId);
        const url = isEditing
          ? `${apiBaseUrl}/plants/${editingPlantId}`
          : `${apiBaseUrl}/plants`;

        try {
          const thresholdsPayload = buildPlantThresholdsPayload();
          const response = await fetch(url, {
            method: isEditing ? "PUT" : "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify({
              name,
              deviceId,
              thresholds: thresholdsPayload,
            }),
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(
              data?.error ||
                (isEditing
                  ? "No se pudo actualizar la planta."
                  : "No se pudo crear la planta."),
            );
          }

          const updatedPlant = data?.plant || data;
          plantStatus.textContent = isEditing
            ? data?.message ||
              `Planta "${updatedPlant?.name || name}" actualizada correctamente.`
            : `Planta "${updatedPlant?.name || name}" creada correctamente.`;
          plantStatus.className = "text-success small";
          registerKnownDevice(deviceId);
          resetPlantForm();
          await loadPlants();
        } catch (error) {
          console.error(error);
          plantStatus.textContent =
            error instanceof Error ? error.message : "Error desconocido.";
          plantStatus.className = "text-danger small";
        }
      }

      function buildPlantThresholdsPayload() {
        const rows = plantThresholdsBody?.querySelectorAll("[data-sensor-row]");
        const payload = {};
        const errors = [];

        if (!rows) return payload;

        rows.forEach((row) => {
          const sensor = row.getAttribute("data-sensor");
          const meta = SENSOR_METADATA[sensor] || {};
          const minInput = row.querySelector('[data-threshold="min"]');
          const maxInput = row.querySelector('[data-threshold="max"]');
          const values = {};

          if (minInput && !minInput.disabled) {
            const minValue = minInput.value.trim();
            if (minValue) {
              const parsed = Number(minValue);
              if (Number.isNaN(parsed)) {
                errors.push(`El mínimo para ${meta.name} no es válido.`);
              } else {
                values.min = parsed;
              }
            }
          } else if (meta.fixedMin !== undefined) {
            values.min = meta.fixedMin;
          }

          if (maxInput && !maxInput.disabled) {
            const maxValue = maxInput.value.trim();
            if (maxValue) {
              const parsed = Number(maxValue);
              if (Number.isNaN(parsed)) {
                errors.push(`El máximo para ${meta.name} no es válido.`);
              } else {
                values.max = parsed;
              }
            }
          }

          if (Object.keys(values).length === 0) {
            const example = meta.examples || {};
            if (example.min !== undefined) values.min = example.min;
            if (example.max !== undefined) values.max = example.max;
          }

          payload[sensor] = values;
        });

        if (errors.length) {
          throw new Error(errors.join(" "));
        }

        return payload;
      }

      function collectCurrentPlantThresholdValues() {
        const rows = plantThresholdsBody?.querySelectorAll("[data-sensor-row]");
        const current = {};
        if (!rows) {
          return current;
        }

        rows.forEach((row) => {
          const sensor = row.getAttribute("data-sensor");
          if (!sensor) return;
          const minInput = row.querySelector('[data-threshold="min"]');
          const maxInput = row.querySelector('[data-threshold="max"]');
          const values = {};

          if (
            minInput &&
            !minInput.disabled &&
            !minInput.hasAttribute("readonly")
          ) {
            const trimmed = minInput.value.trim();
            if (trimmed) values.min = trimmed;
          } else if (
            minInput &&
            minInput.hasAttribute("readonly") &&
            minInput.value.trim()
          ) {
            values.min = minInput.value.trim();
          }

          if (maxInput && !maxInput.disabled) {
            const trimmed = maxInput.value.trim();
            if (trimmed) values.max = trimmed;
          }

          current[sensor] = values;
        });
        return current;
      }

      function persistPlantFormDraft() {
        const draft = {
          name: plantNameInput?.value || "",
          deviceId: plantDeviceInput?.value || "",
          thresholds: collectCurrentPlantThresholdValues(),
          editingPlantId,
        };
        saveSessionState(SESSION_KEYS.plantDraft, draft);
      }

      function restorePlantFormDraft() {
        const draft = loadSessionState(SESSION_KEYS.plantDraft);
        if (!draft) return;
        if (plantNameInput && typeof draft.name === "string") {
          plantNameInput.value = draft.name;
        }
        if (plantDeviceInput && typeof draft.deviceId === "string") {
          plantDeviceInput.value = draft.deviceId;
        }
        if (draft.thresholds) {
          applyPlantThresholdValues(draft.thresholds);
        }
        if (draft.editingPlantId) {
          editingPlantId = draft.editingPlantId;
          if (plantSubmitBtn) {
            plantSubmitBtn.innerHTML =
              '<i class="bi bi-pencil-square"></i> Actualizar planta';
            plantSubmitBtn.classList.remove("btn-success");
            plantSubmitBtn.classList.add("btn-warning");
          }
          if (plantCancelEditCol) {
            plantCancelEditCol.classList.remove("d-none");
          }
          if (plantStatus) {
            plantStatus.textContent =
              "Continuas una edición pendiente. Ajusta y guarda los cambios.";
            plantStatus.className = "text-warning small";
          }
        }
      }

      function resetPlantForm(options = {}) {
        const { keepDraft = false } = options;
        editingPlantId = null;
        if (plantForm) {
          plantForm.reset();
        }
        renderPlantThresholdRows();
        if (!keepDraft) {
          clearSessionState(SESSION_KEYS.plantDraft);
        }
        if (plantSubmitBtn) {
          plantSubmitBtn.innerHTML = `<i class="bi bi-plant"></i> Crear planta`;
          plantSubmitBtn.classList.add("btn-success");
          plantSubmitBtn.classList.remove("btn-warning");
        }
        if (plantCancelEditCol) {
          plantCancelEditCol.classList.add("d-none");
        }
        if (plantDeviceInput) {
          const sanitized = plantDeviceInput.value?.trim();
          plantDeviceInput.value = sanitized || "ESP32_1";
        }
      }

      function renderPlantThresholdRows() {
        if (!plantThresholdsBody) return;
        const rows = Object.entries(SENSOR_METADATA)
          .map(([sensor, meta]) => {
            const exampleMin =
              meta.examples?.min !== undefined ? meta.examples.min : "";
            const exampleMax =
              meta.examples?.max !== undefined ? meta.examples.max : "";

            const minField = meta.readOnly
              ? `<input type="number" class="form-control form-control-sm" data-threshold="min" value="${meta.fixedMin ?? ""}" ${
                  meta.fixedMin === undefined ? "disabled" : "readonly"
                } />`
              : `<input type="number" class="form-control form-control-sm" data-threshold="min" placeholder="${
                  exampleMin ? `Ej: ${exampleMin}` : "Ej: 15"
                }" value="${exampleMin !== "" ? exampleMin : ""}" />`;

            const disableMax = meta.readOnly;
            const maxField = disableMax
              ? `<input type="text" class="form-control form-control-sm" data-threshold="max" value="No aplica" disabled />`
              : `<input type="number" class="form-control form-control-sm" data-threshold="max" placeholder="${
                  exampleMax ? `Ej: ${exampleMax}` : "Ej: 35"
                }" value="${exampleMax !== "" ? exampleMax : ""}" />`;

            return `<tr data-sensor-row data-sensor="${sensor}">
              <td>${getSensorName(sensor)}</td>
              <td>${minField}</td>
              <td>${maxField}</td>
            </tr>`;
          })
          .join("");
        plantThresholdsBody.innerHTML = rows;
      }

      function applyPlantThresholdValues(thresholds) {
        if (!plantThresholdsBody) return;
        const rows = plantThresholdsBody.querySelectorAll("[data-sensor-row]");
        rows.forEach((row) => {
          const sensor = row.getAttribute("data-sensor");
          if (!sensor) return;
          const values =
            thresholds && typeof thresholds === "object"
              ? thresholds[sensor] || {}
              : {};
          const minInput = row.querySelector('[data-threshold="min"]');
          const maxInput = row.querySelector('[data-threshold="max"]');
          if (minInput) {
            if (values.min !== undefined && values.min !== null) {
              minInput.value = String(values.min);
            } else if (!minInput.hasAttribute("readonly") && !minInput.disabled) {
              minInput.value = "";
            }
          }
          if (maxInput) {
            if (values.max !== undefined && values.max !== null) {
              maxInput.value = String(values.max);
            } else if (!maxInput.disabled) {
              maxInput.value = "";
            }
          }
        });
      }

      async function loadPlants() {
        if (!requireAuthToken()) return;
        if (!plantsTableBody) return;

        plantStatus.textContent = "Cargando plantas...";
        plantStatus.className = "text-muted small";

        try {
          const response = await fetch(`${apiBaseUrl}/plants`, {
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          });
          const data = await response.json();
          if (!response.ok) {
            throw new Error(
              data?.error || "No se pudieron cargar las plantas.",
            );
          }

          renderPlantsTable(data);
          const plantCount = Array.isArray(data) ? data.length : 0;
          plantStatus.textContent = `Se encontraron ${plantCount} planta(s).`;
          plantStatus.className = "text-success small";
        } catch (error) {
          console.error(error);
          plantStatus.textContent =
            error instanceof Error ? error.message : "Error desconocido.";
          plantStatus.className = "text-danger small";
        }
      }

      function renderPlantsTable(plants) {
        if (!plantsTableBody) return;
        cachedPlants = Array.isArray(plants) ? plants : [];

        if (!cachedPlants.length) {
          plantsTableBody.innerHTML = `
            <tr>
              <td colspan="5" class="text-center text-muted">No hay plantas registradas.</td>
            </tr>`;
          return;
        }

        plantsTableBody.innerHTML = cachedPlants
          .map((plant) => {
            const deviceId = plant.deviceId || "ESP32_1";
            registerKnownDevice(deviceId);
            const thresholdsSummary = Object.keys(SENSOR_METADATA)
              .map((sensor) => {
                const meta = SENSOR_METADATA[sensor];
                const values = plant.thresholds?.[sensor] || {};
                const minLabel =
                  values.min !== undefined
                    ? formatSensorValue(sensor, values.min)
                    : "—";
                const maxLabel =
                  values.max !== undefined
                    ? formatSensorValue(sensor, values.max)
                    : "—";
                return `<div><strong>${meta.name}:</strong> ${minLabel} / ${maxLabel}</div>`;
              })
              .join("");
            const plantId = getPlantIdentifier(plant);
            const actionsHtml = plantId
              ? `<div class="btn-group btn-group-sm flex-wrap justify-content-center" role="group">
                  <button type="button" class="btn btn-outline-primary" data-plant-action="edit" data-plant-id="${plantId}" title="Editar planta">
                    <i class="bi bi-pencil-square me-1"></i>Editar
                  </button>
                  <button type="button" class="btn btn-outline-danger" data-plant-action="delete" data-plant-id="${plantId}" title="Eliminar planta">
                    <i class="bi bi-trash me-1"></i>Eliminar
                  </button>
                </div>`
              : `<span class="text-muted">N/D</span>`;

            return `<tr>
              <td>${plant.name}</td>
              <td>${deviceId}</td>
              <td>${thresholdsSummary}</td>
              <td>${plant.updatedAt ? new Date(plant.updatedAt).toLocaleString() : "—"}</td>
              <td class="text-center">${actionsHtml}</td>
            </tr>`;
          })
          .join("");
      }

      function getPlantIdentifier(plant) {
        if (!plant || typeof plant !== "object") return undefined;
        return (
          plant._id ||
          plant.id ||
          plant.plantId ||
          plant.uuid ||
          plant.identifier ||
          undefined
        );
      }

      function findPlantById(plantId) {
        if (!plantId) return undefined;
        return cachedPlants.find(
          (plant) => getPlantIdentifier(plant) === plantId,
        );
      }

      async function deletePlantById(plantId) {
        if (!requireAuthToken()) return;
        try {
          const response = await fetch(`${apiBaseUrl}/plants/${plantId}`, {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              data?.error || "No se pudo eliminar la planta seleccionada.",
            );
          }

          if (plantStatus) {
            plantStatus.textContent =
              data?.message || "Planta eliminada correctamente.";
            plantStatus.className = "text-success small";
          }

          if (editingPlantId === plantId) {
            resetPlantForm();
          }

          await loadPlants();
        } catch (error) {
          console.error(error);
          if (plantStatus) {
            plantStatus.textContent =
              error instanceof Error ? error.message : "Error desconocido.";
            plantStatus.className = "text-danger small";
          }
        }
      }

      function startPlantEdit(plant) {
        if (!plant) return;
        const plantId = getPlantIdentifier(plant);
        if (!plantId) {
          console.warn("No se pudo determinar el ID de la planta seleccionada.");
          return;
        }
        editingPlantId = plantId;
        renderPlantThresholdRows();
        applyPlantThresholdValues(plant.thresholds || {});
        if (plantNameInput) {
          plantNameInput.value = plant.name || "";
        }
        if (plantDeviceInput) {
          plantDeviceInput.value = plant.deviceId || "ESP32_1";
        }
        if (plantSubmitBtn) {
          plantSubmitBtn.innerHTML =
            '<i class="bi bi-pencil-square"></i> Actualizar planta';
          plantSubmitBtn.classList.remove("btn-success");
          plantSubmitBtn.classList.add("btn-warning");
        }
        if (plantCancelEditCol) {
          plantCancelEditCol.classList.remove("d-none");
        }
        if (plantStatus) {
          plantStatus.textContent = `Editando "${plant.name}". Ajusta los umbrales y guarda los cambios.`;
          plantStatus.className = "text-warning small";
        }
        plantNameInput?.focus();
        if (plantForm?.scrollIntoView) {
          plantForm.scrollIntoView({ behavior: "smooth", block: "start" });
        }
        persistPlantFormDraft();
      }

      async function handleFcmSubmit(event) {
        event.preventDefault();
        if (!requireAuthToken()) return;

        const token = fcmTokenInput.value.trim();
        if (!token) {
          alert("El token FCM es obligatorio.");
          return;
        }

        try {
          const response = await fetch(`${apiBaseUrl}/notifications/tokens`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify({
              token,
              deviceId: fcmDeviceIdInput.value.trim() || undefined,
              platform: fcmPlatformInput.value || undefined,
            }),
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data?.error || "No se pudo registrar el token.");
          }

          fcmStatus.textContent = `Token registrado (ID: ${data.id}).`;
          fcmStatus.className = "text-success small";
          registerKnownDevice(data.deviceId || "");
        } catch (error) {
          console.error(error);
          fcmStatus.textContent =
            error instanceof Error ? error.message : "Error desconocido.";
          fcmStatus.className = "text-danger small";
        }
      }

      function persistFcmFormState() {
        const draft = {
          token: fcmTokenInput?.value || "",
          deviceId: fcmDeviceIdInput?.value || "",
          platform: fcmPlatformInput?.value || "",
        };
        saveSessionState(SESSION_KEYS.fcmDraft, draft);
      }

      function restoreFcmFormState() {
        const draft = loadSessionState(SESSION_KEYS.fcmDraft);
        if (!draft) return;
        if (fcmTokenInput && typeof draft.token === "string") {
          fcmTokenInput.value = draft.token;
        }
        if (fcmDeviceIdInput && typeof draft.deviceId === "string") {
          fcmDeviceIdInput.value = draft.deviceId;
        }
        if (fcmPlatformInput && typeof draft.platform === "string") {
          fcmPlatformInput.value = draft.platform;
        }
      }

      function handleSensorFormSubmit(event) {
        event.preventDefault();
        const deviceId = sensorDeviceInput.value.trim();
        const sensorType = sensorTypeSimulation.value;
        const valueRaw = sensorValueInput.value.trim();
        const unitValue =
          sensorUnitInput.value.trim() ||
          getSensorUnit(sensorType) ||
          undefined;

        if (!deviceId) {
          alert("Debes especificar un dispositivo.");
          return;
        }

        const parsedValue = Number(valueRaw);
        if (Number.isNaN(parsedValue)) {
          alert("El valor debe ser numérico.");
          return;
        }

        const payload = [
          {
            deviceId,
            sensorType,
            value: parsedValue,
            unit: unitValue || "",
          },
        ];

        sendWsMessage(JSON.stringify(payload));
        sensorStatus.textContent = `Lectura enviada para ${deviceId} / ${getSensorName(
          sensorType,
        )}.`;
        sensorStatus.className = "text-success small";
      }

      function persistSensorFormState() {
        const draft = {
          deviceId: sensorDeviceInput?.value || "",
          sensorType: sensorTypeSimulation?.value || "",
          value: sensorValueInput?.value || "",
          unit: sensorUnitInput?.value || "",
        };
        saveSessionState(SESSION_KEYS.sensorDraft, draft);
      }

      function restoreSensorFormState() {
        const draft = loadSessionState(SESSION_KEYS.sensorDraft);
        if (!draft) return;
        if (sensorDeviceInput && typeof draft.deviceId === "string") {
          sensorDeviceInput.value = draft.deviceId;
        }
        if (
          sensorTypeSimulation &&
          typeof draft.sensorType === "string" &&
          SENSOR_METADATA[draft.sensorType]
        ) {
          sensorTypeSimulation.value = draft.sensorType;
        }
        updateSensorSimulationHints();
        if (sensorValueInput && typeof draft.value === "string") {
          sensorValueInput.value = draft.value;
        }
        if (sensorUnitInput && typeof draft.unit === "string") {
          sensorUnitInput.value = draft.unit;
        }
      }

      function updateSensorSimulationHints() {
        if (!sensorTypeSimulation) return;
        const meta = SENSOR_METADATA[sensorTypeSimulation.value] || {};
        if (sensorUnitInput && meta.unit) {
          sensorUnitInput.value = meta.unit;
        }
        if (sensorValueInput && meta.examples) {
          if (meta.examples.max !== undefined) {
            sensorValueInput.placeholder = `Ej: ${meta.examples.max}`;
          } else if (meta.examples.min !== undefined) {
            sensorValueInput.placeholder = `Ej: ${meta.examples.min}`;
          }
        }
      }

      // --- CREACIÓN DE TARJETAS DE DISPOSITIVOS ---
      function createDeviceCard(deviceId) {
        if (document.getElementById(`device-${deviceId}`)) return;

        registerKnownDevice(deviceId);

        const card = document.createElement("div");
        card.className = "card mb-3 shadow-sm";
        card.id = `device-${deviceId}`;
        card.innerHTML = `
          <div class="card-header d-flex justify-content-between align-items-center">
            <span>Dispositivo: <strong>${deviceId}</strong></span>
            <button class="btn btn-sm btn-outline-danger" onclick="unsubscribe('${deviceId}')">
              <i class="bi bi-x-circle"></i> Dejar de seguir
            </button>
          </div>
          <div class="card-body">
            <h5 class="card-title">Lecturas de Sensores</h5>
            <ul class="list-group list-group-flush" id="sensors-list-${deviceId}"></ul>
          </div>
        `;
        devicesContainer.appendChild(card);
      }

      function unsubscribe(deviceId) {
        if (!subscribedDevices.has(deviceId)) return;
        sendWsMessage(
          JSON.stringify({ event: "unsubscribeFromDevice", deviceId }),
        );
        subscribedDevices.delete(deviceId);
        persistSubscribedDevices();
        document.getElementById(`device-${deviceId}`)?.remove();
        logMessage(`Desuscrito de ${deviceId}`);
      }

      function updateSensorCard(deviceId, sensorType, value, unit) {
        registerKnownDevice(deviceId);
        if (!subscribedDevices.has(deviceId)) return;

        const sensorList = document.getElementById(`sensors-list-${deviceId}`);
        if (!sensorList) return;

        let sensorItem = document.getElementById(
          `sensor-${deviceId}-${sensorType}`,
        );

        if (!sensorItem) {
          sensorItem = document.createElement("li");
          sensorItem.className =
            "list-group-item d-flex justify-content-between align-items-center";
          sensorItem.id = `sensor-${deviceId}-${sensorType}`;
          const icon = getSensorIcon(sensorType);
          const name = getSensorName(sensorType);
          const formattedValue = formatSensorValue(sensorType, value, unit);

          sensorItem.innerHTML = `
            <span>${icon} <strong class="ms-2">${name}:</strong></span>
            <span class="badge bg-primary rounded-pill fs-6" id="value-${deviceId}-${sensorType}">
              ${formattedValue}
            </span>`;
          sensorList.appendChild(sensorItem);
        } else {
          const badge = document.getElementById(
            `value-${deviceId}-${sensorType}`,
          );
          badge.textContent = formatSensorValue(sensorType, value, unit);
          badge.classList.replace("bg-primary", "bg-success");
          setTimeout(
            () => badge.classList.replace("bg-success", "bg-primary"),
            500,
          );
        }
      }

      // --- NOTIFICACIONES ---
      document.addEventListener("DOMContentLoaded", () => {
        if ("Notification" in window && Notification.permission !== "granted") {
          Notification.requestPermission();
        }
      });

      function showNotification(title, body) {
        if (Notification.permission === "granted") {
          new Notification(title, { body });
        }
      }

      // --- UTILS ---
      function getSensorUnit(type, fallbackUnit = "") {
        return SENSOR_METADATA[type]?.unit || fallbackUnit || "";
      }

      function formatSensorValue(sensorType, value, fallbackUnit = "") {
        const meta = SENSOR_METADATA[sensorType];
        const decimals = meta?.decimals ?? 2;
        const numericValue = typeof value === "number" ? value : Number(value);
        const formattedValue = Number.isFinite(numericValue)
          ? numericValue.toFixed(decimals)
          : String(value);
        const unitLabel = getSensorUnit(sensorType, fallbackUnit);
        return unitLabel ? `${formattedValue} ${unitLabel}` : formattedValue;
      }

      function getSensorName(type) {
        return SENSOR_METADATA[type]?.name || type;
      }

      function getSensorIcon(type) {
        return (
          SENSOR_METADATA[type]?.icon || '<i class="bi bi-cpu text-muted"></i>'
        );
      }

      function updateThresholdHints() {
        if (!sensorTypeSelect) return;
        const selectedType = sensorTypeSelect.value;
        const meta = SENSOR_METADATA[selectedType] || {};
        const sensorName = meta.name || selectedType;
        const unitLabel = meta.unit || "";
        const examples = meta.examples || {};
        const isReadOnly = !!meta.readOnly;
        const disableMin = selectedType === "solar_radiation" || isReadOnly;
        const disableMax =
          selectedType === "solar_radiation" ? false : isReadOnly;

        if (minThresholdInput) {
          minThresholdInput.disabled = disableMin;
          if (disableMin) {
            if (meta.fixedMin !== undefined) {
              const fixedMinStr = String(meta.fixedMin);
              minThresholdInput.value = fixedMinStr;
              minThresholdInput.placeholder = fixedMinStr;
            } else {
              minThresholdInput.value = "";
              minThresholdInput.placeholder = "No aplica";
            }
          } else {
            minThresholdInput.placeholder =
              examples.min !== undefined ? `Ej: ${examples.min}` : "Ej: 15";
          }
        }

        if (maxThresholdInput) {
          maxThresholdInput.disabled = disableMax;
          if (disableMax) {
            maxThresholdInput.value = "";
            maxThresholdInput.placeholder = "No aplica";
          } else {
            maxThresholdInput.placeholder =
              examples.max !== undefined ? `Ej: ${examples.max}` : "Ej: 35";
          }
        }

        if (minThresholdHelp) {
          if (meta.fixedMin !== undefined) {
            minThresholdHelp.textContent = `El umbral mínimo para ${sensorName} es fijo (${meta.fixedMin}${
              unitLabel ? ` ${unitLabel}` : ""
            }).`;
          } else if (disableMin) {
            minThresholdHelp.textContent = `No se requiere mínimo para ${sensorName}.`;
          } else {
            minThresholdHelp.textContent = unitLabel
              ? `Define el valor mínimo permitido para ${sensorName} en ${unitLabel}.`
              : `Define el valor mínimo permitido para ${sensorName}.`;
          }
        }

        if (maxThresholdHelp) {
          if (isReadOnly) {
            maxThresholdHelp.textContent = `El umbral máximo para ${sensorName} no es configurable.`;
          } else if (disableMax) {
            maxThresholdHelp.textContent = `No se requiere máximo para ${sensorName}.`;
          } else {
            maxThresholdHelp.textContent = unitLabel
              ? `Define el valor máximo permitido para ${sensorName} en ${unitLabel}.`
              : `Define el valor máximo permitido para ${sensorName}.`;
          }
        }
      }

      function persistThresholdFormState() {
        const draft = {
          deviceId: thresholdDeviceInput?.value || "",
          sensorType: sensorTypeSelect?.value || "",
          min: minThresholdInput?.value || "",
          max: maxThresholdInput?.value || "",
        };
        saveSessionState(SESSION_KEYS.thresholdDraft, draft);
      }

      function restoreThresholdFormState() {
        const draft = loadSessionState(SESSION_KEYS.thresholdDraft);
        if (!draft) return;
        if (thresholdDeviceInput && typeof draft.deviceId === "string") {
          thresholdDeviceInput.value = draft.deviceId;
        }
        if (
          sensorTypeSelect &&
          typeof draft.sensorType === "string" &&
          SENSOR_METADATA[draft.sensorType]
        ) {
          sensorTypeSelect.value = draft.sensorType;
        }
        updateThresholdHints();
        if (minThresholdInput && typeof draft.min === "string") {
          minThresholdInput.value = draft.min;
        }
        if (maxThresholdInput && typeof draft.max === "string") {
          maxThresholdInput.value = draft.max;
        }
      }

      function logMessage(message) {
        const p = document.createElement("p");
        p.className = "mb-1";
        p.innerHTML = `<code>[${new Date().toLocaleTimeString()}]</code> ${message}`;
        logs.appendChild(p);
        logs.scrollTop = logs.scrollHeight;
      }
    </script>
  </body>
</html>
